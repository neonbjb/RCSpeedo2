package com.appliedanalog.rcspeedo.controllers;import android.media.AudioFormat;import android.media.AudioRecord;import android.media.MediaRecorder;import android.util.Log;import com.appliedanalog.rcspeedo.doppler.FrameReader;public class MicHandler implements FrameReader {    final String TAG = "MicHandler";    AudioRecord recorder;    boolean recording = false;    int frame_sz;    int new_samples_per_frame;    int samp_rate;    int rotating_buffer_ptr;    short[] buf;    /**     * Constructs MicHandler object     *     * @param fs          The desired working frame size     * @param fs_samprate The audio sample rate at which that frame size is valid. MicHandler will scale the frame size if the     *                    <p/>     *                    actual sample rate is larger than the specified one.     */    public MicHandler(int fs, int fs_samprate) {        frame_sz = fs;        new_samples_per_frame = fs;        rotating_buffer_ptr = 0;        recorder = openAudio();        if (recorder == null) {            Log.e(TAG, "Error initializing recorder");            return;        }        if (fs_samprate > samp_rate) {            Log.e(TAG, "Recorder incapable of recording at " + samp_rate + " aborting initialization.");            if (recorder != null) {                recorder.release();                recorder = null;            }            return;        }        buf = new short[fs];    }    private AudioRecord openAudio() {        int[] samplingRates = {44100, 22050, 16000, 11025, 8000};        for (int i = 0; i < samplingRates.length; ++i) {            try {                int min = AudioRecord.getMinBufferSize(samplingRates[i],                        AudioFormat.CHANNEL_CONFIGURATION_MONO,                        AudioFormat.ENCODING_PCM_16BIT);                if (min < 4096)                    min = 4096;                min = min * 8;                AudioRecord record = new AudioRecord(MediaRecorder.AudioSource.MIC, samplingRates[i],                        AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, min);                if (record.getState() == AudioRecord.STATE_INITIALIZED) {                    Log.d(TAG, "Audio recorder initialised at " + record.getSampleRate());                    samp_rate = samplingRates[i];                    return record;                }                record.release();                record = null;            } catch (IllegalArgumentException e) {            }        }        // None worked.        return null;    }    public boolean startRecording() {        if (recorder == null) {            return false;        }        recorder.startRecording();        recording = true;        return true;    }    public void stopRecording() {        recording = false;        recorder.stop();    }    public void releaseRecorder() {        recorder.release();    }    public short[] readFrame() {        if (frame_sz == new_samples_per_frame) {            rotating_buffer_ptr = 0;            recorder.read(buf, 0, frame_sz);        } else {            recorder.read(buf, rotating_buffer_ptr, new_samples_per_frame);            rotating_buffer_ptr = (rotating_buffer_ptr + new_samples_per_frame) % frame_sz;        }        return buf;    }    public int getRotatingPointer() {        return rotating_buffer_ptr;    }    public int getSamplingRate() {        return samp_rate;    }    public void setFeedParameters(int fs, int nspf) {        frame_sz = fs;        new_samples_per_frame = nspf;        if (fs != buf.length) {            buf = new short[fs];        }    }}