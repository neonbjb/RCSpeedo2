/* * Copyright Applied Analog (c) 2015/2016 * * This code is free for use in any non-commercial software. It carries * no restrictions in such software. */package com.appliedanalog.rcspeedo.controllers;import android.media.AudioFormat;import android.media.AudioRecord;import android.media.MediaRecorder;import android.util.Log;/** * Class that provides a FrameReader interface from the Android microphone API. */public class MicHandler {    final String TAG = "MicHandler";    AudioRecord mRecorder;    boolean mIsRecording = false;    int mFrameSize;    int mNewSamplesPerFrame;    int mSampleRate;    int mRotatingBufferPtr;    short[] mBuffer;    /**     * Constructs MicHandler object     *     * @param aFrameSize          The desired working frame size     * @param aSampleRate The audio sample rate at which that frame size is valid. MicHandler will scale the frame size if the     *                    <p/>     *                    actual sample rate is larger than the specified one.     */    public MicHandler(int aFrameSize, int aSampleRate) {        mRecorder = openAudio();        configurationChanged(aFrameSize, aSampleRate);    }    /**     * Should be called whenever the frame size or sample rate expected by AudioDoppler is changed.     * @param aFrameSize     * @param aSampleRate     */    public void configurationChanged(int aFrameSize, int aSampleRate) {        mFrameSize = aFrameSize;        mNewSamplesPerFrame = aFrameSize;        mRotatingBufferPtr = 0;        if (mRecorder == null) {            Log.e(TAG, "Error initializing mRecorder");            return;        }        if (aSampleRate > mSampleRate) {            Log.e(TAG, "Recorder incapable of mIsRecording at " + mSampleRate + " aborting initialization.");            if (mRecorder != null) {                mRecorder.release();                mRecorder = null;            }            return;        }        mBuffer = new short[aFrameSize];    }    /**     * Begin listening to the microphone.     * @return     */    public boolean startRecording() {        if (mRecorder == null) {            return false;        }        mRecorder.startRecording();        mIsRecording = true;        return true;    }    /**     * Stop listening to the microphone.     */    public void stopRecording() {        mIsRecording = false;        mRecorder.stop();    }    /**     * Release the hardware resources bound to this object.     */    public void releaseRecorder() {        mRecorder.release();    }    /**     * Called when the AudioDoppler needs a frame of data.     * @return     */    public short[] readFrame() {        if (mFrameSize == mNewSamplesPerFrame) {            mRotatingBufferPtr = 0;            mRecorder.read(mBuffer, 0, mFrameSize);        } else {            mRecorder.read(mBuffer, mRotatingBufferPtr, mNewSamplesPerFrame);            mRotatingBufferPtr = (mRotatingBufferPtr + mNewSamplesPerFrame) % mFrameSize;        }        return mBuffer;    }    /**     * Get the index into the rotating buffer (as returned from readFrame()) which should be read from     * as the start index.     * @return     */    public int getRotatingPointer() {        return mRotatingBufferPtr;    }    public int getSamplingRate() {        return mSampleRate;    }    public void setFeedParameters(int fs, int nspf) {        mFrameSize = fs;        mNewSamplesPerFrame = nspf;        if (fs != mBuffer.length) {            mBuffer = new short[fs];        }    }    private AudioRecord openAudio() {        int[] samplingRates = {44100, 22050, 16000, 11025, 8000};        for (int i = 0; i < samplingRates.length; ++i) {            try {                int min = AudioRecord.getMinBufferSize(samplingRates[i],                        AudioFormat.CHANNEL_CONFIGURATION_MONO,                        AudioFormat.ENCODING_PCM_16BIT);                if (min < 4096)                    min = 4096;                min = min * 8;                AudioRecord record = new AudioRecord(MediaRecorder.AudioSource.MIC, samplingRates[i],                        AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, min);                if (record.getState() == AudioRecord.STATE_INITIALIZED) {                    Log.d(TAG, "Audio mRecorder initialised at " + record.getSampleRate());                    mSampleRate = samplingRates[i];                    return record;                }                record.release();                record = null;            } catch (IllegalArgumentException e) {            }        }        // None worked.        return null;    }}